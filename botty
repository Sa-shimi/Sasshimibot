import telebot
import random
import networkx as nx
import pandas as pd
from itertools import combinations
from random import randrange
import numpy as np
import matplotlib.pyplot as plt
import time
import contagion
from bob_telegram_tools.bot import TelegramBot as tb

bot = telebot.TeleBot('2125748147:AAHiKWSFJ7vXqFBPLu0qjNYHPuFt1zL3uqo')


data = []
def step_Set_Price(message):
    cid = message.chat.id
    userPrice = message.text


@bot.message_handler(commands=['start'])
def greet(message):
    bot.reply_to(message,
                 "Ciao! Sono il bot di Sashi. Sono la sua potenziale coscienza cibernetica. "
                 "Sono stata sviluppata in una noiosa domenica. Se vuoi scrivermi, ricordati di scrivere "
                 "correttamente. Evita punteggiatura eccessiva (e.g. !!!) . Evita di essere noios…ô."
                 "Sono anche la sua assistente virtuale. "
                 "Se vuoi scoprire quali cose posso fare, chiedimi di mostrarti i /Commands che posso eseguire."
                 "Ti ricordo vuoi esegurie delle analisi, devi contattare il mio collega https://t.me/Nigirizushibot")


@bot.message_handler(commands=['Commands'])
def listacomandi(message):
    bot.reply_to(message,
                 "Qui puoi eseguire una serie di comandi. ecco una lista: \n/Contagion \n \n/Steps \n \n/Parameter_analysis."
                 "\nIn order to execute a specific analysis, you just need to click on it")


@bot.message_handler(commands=['Go_back_to_menu'])
def listacomandi(message):
    bot.reply_to(message,
                 "Qui puoi eseguire una serie di comandi. ecco una lista: \n /Contagion\n \n /Steps \n \n /Parameter_analysis."
                 "\nIn order to execute a specific analysis, you just need to click on it")


@bot.message_handler(commands=['Contagion','Go_back_to_Contagion'])
def greet(message):
    bot.reply_to(message, "Excellent choice, dear. This type of analysis will execute the Bass (1969), the DeGroot (1974)"
                          "and the Piccione-Tolotti model (2022) on a randomly generated"
                          "network (Barabasi random graph). Before proceeding, we need to define the parameters necessary."
                          "For instance, we need to define:"
                          "\nThe number of nodes on our network; \nThe k parameter (da spiegare); \nThe number of time steps;\nFinally,"
                          "The number of simulations"
                          "Do you want to proceed?"
                          "\n/Yes_I_want_to_proceed_with_contagion_analysis"
                          "\n/Go_back_to_menu")


@bot.message_handler(commands=['Yes_I_want_to_proceed_with_contagion_analysis','Yes_I_want_to_restart_the_contagion_analysis'])
def handle_text(message):
    del data[:]
    cid = message.chat.id
    msgValuenodes = bot.send_message(cid, 'How many nodes does the network have?')
    bot.register_next_step_handler(msgValuenodes, step_Set_Valuenodes)



def step_Set_Valuenodes(message):
    userValuenodes = message.text
    if userValuenodes.isnumeric() == True:
        print(userValuenodes)
        msgValuek = bot.send_message(message.chat.id,
                                 'The network will have {} nodes. \nWhat is the value of k? (suggested, between 1 and 15)'.format(
                                     userValuenodes))
        bot.register_next_step_handler(msgValuek, step_Set_Valuek)
        data.append(int(userValuenodes))
    else:
        bot.send_message(message.chat.id, "The input is not valid. Utilize only integer numbers. The process is being interrupted. Do you want"
                                          " to restart the process"
                                          "\n/Yes_I_want_to_restart_the_contagion_analysis"
                                          "\n No, /Go_back_to_menu")


def step_Set_Valuek(message):
    userValuek = message.text
    if userValuek.isnumeric() == True:
        if 1 < int(userValuek) < data[0]:
            print(userValuek)
            msgValuesteps = bot.send_message(message.chat.id,
                                             'The parameter k will have a value of {}. \nHow many steps do we want in each simulation?'.format(
                                                 userValuek))
            bot.register_next_step_handler(msgValuesteps, step_Set_Valuesteps)
            data.append(int(userValuek))
        else:
            bot.send_message(message.chat.id, "Attention! The parameter k has to be lower than the number of nodes and higher than 1."
                                              " The process is being interrupted. Do you want to restart the process?"
                                              "\n/Yes_I_want_to_restart_the_contagion_analysis"
                                              "\n No, /Go_back_to_menu")

    else:
        bot.send_message(message.chat.id,
                         "Utilize only integer numbers. The process is being interrupted. Do you want"
                         " to restart the process?"
                         "\n/Yes_I_want_to_restart_the_contagion_analysis"
                         "\n No, /Go_back_to_menu")



def step_Set_Valuesteps(message):
    userValuesteps = message.text
    if userValuesteps.isnumeric() == True:
        print(userValuesteps)
        msgValuesimulations = bot.send_message(message.chat.id, 'The number of steps for each simulation will be {}.'
                                                                '\nHow many times do you want to repeat the simulations?'.format(
            userValuesteps))
        bot.register_next_step_handler(msgValuesimulations, step_Set_Valuesimulations)
        data.append(int(userValuesteps))

    else:
        bot.send_message(message.chat.id, "Utilize only integer numbers. The process is being interrupted. Do you want"
                                          " to restart the process?"
                                          "\n/Yes_I_want_to_restart_the_contagion_analysis"
                                          "\n No, /Go_back_to_menu")



def step_Set_Valuesimulations(message):
    userValuesimulations = message.text
    if userValuesimulations.isnumeric() == True:
        print(userValuesimulations)
        bot.send_message(message.chat.id, "{} simulations will be carried out.".format(userValuesimulations))
        data.append(int(userValuesimulations))
        msgValueprime = bot.send_message(message.chat.id, "How many subjects are aware of the information at time 0?")
        bot.register_next_step_handler(msgValueprime,step_set_Valueprime)

def step_set_Valueprime(message):
    userValueprime = message.text
    if userValueprime.isnumeric()==True:
        print(userValueprime)
        data.append(int(userValueprime))
        bot.send_message(message.chat.id, "{} people will be aware of the information at time t=0.".format(userValueprime))
        message_confirmation = bot.send_message(message.chat.id,
                                                "Summarizing. \nYou want to carry out {} simulations, each of which composed by {} time steps"
                                                " regarding the Bass, the DeGroot and the Piccione-Tolotti models on a network of {} nodes built with a k of value."
                                                "\nAt time 0, {} people will be aware of the information."
                                                "\nDo you confirm?"
                                                "\n/Yes"
                                                "\n/Go_back (click twice)"
                                                "\n/Go_back_to_menu (click twice)".format(data[3], data[2], data[0], data[1], data[4]))
        bot.register_next_step_handler(message_confirmation, carryiton)

    else:
        bot.send_message(message.chat.id, "Utilize only integer numbers. The process is being interrupted. Do you want"
                                          " to restart the process?"
                                          "\n/Yes_I_want_to_restart_the_contagion_analysis"
                                          "\n No, /Go_back_to_menu")


def carryiton(message):
    if '/Yes' in message.text.split():
        bot.send_message(message.chat.id, "Perfect! The process has been initiated! You will soon receive updates"
                                          " regarding the prosecution of the analyses. Please, for the time remaining,"
                                          " do not write anything")
        bott = tb('2125748147:AAHiKWSFJ7vXqFBPLu0qjNYHPuFt1zL3uqo', message.chat.id)

        iters = data[3]
        steps = data[2]
        par = data[1]
        num = data[0]
        primini=data[4]
        m = 0
        def tutto():
            p = par

            F = nx.random_tree(n=num, create_using=nx.DiGraph, )
            G = nx.barabasi_albert_graph(num, p)

            def combine(arr, s):
                return list(combinations(arr, s))

            def Control_Centrality(F):
                length = len(F.nodes)
                i = 1

                def CC(F):
                    pippa = F.out_degree()
                    pippa1 = np.array(pippa)
                    pippa2 = pippa1[pippa1[:, 1] != 0]
                    F = F.subgraph(pippa2[:, 0])
                    return F

                def layer(F):
                    culo = [x for x in F.nodes if x not in CC(F).nodes]
                    banana = [i] * len(culo)
                    results = np.column_stack((culo, banana))
                    return results

                results = layer(F)
                while len(results) < length:
                    results = np.concatenate([results, layer(F)])
                    results = np.unique(results, axis=0)
                    i += 1
                    F = CC(F)
                    layer(F)
                return dict(zip(results[:, 0], (results[:, 1])))

            BC = nx.betweenness_centrality(F)

            isinstance(BC, dict)
            list(G.nodes)

            lll = combinations(G.nodes(), 2)
            lll = np.matrix(list(lll))
            cliques = list(nx.enumerate_all_cliques(G))
            triads = [i for i in cliques if len(i) == 3]
            simm = []
            for n in triads:
                for l in combine(n, 2):
                    simm.append(l)

            simmelian = []
            for i in simm:
                if i not in simmelian:
                    simmelian.append(i)

            simmelian = np.array(simmelian)

            A = simmelian[:, 0]
            B = simmelian[:, 1]
            A1 = lll[:, 0]
            B1 = lll[:, 1]
            df = pd.DataFrame(simmelian)
            numsimm = len(simmelian)

            BCA = []
            for x in A:
                for n in BC:
                    if x == n:
                        BCA.append(BC[n])
            BCB = []
            for y in B:
                for n in BC:
                    if y == n:
                        BCB.append(BC[n])

            df['BCA'] = BCA
            df['BCB'] = BCB
            df['AVG'] = (df['BCA'] + df['BCB']) / 2
            df['VAR'] = (((df['BCA'] - df['AVG']) ** 2 + (df['BCB'] - df['AVG']) ** 2) / 2)
            VAR = np.sum(df['VAR'])
            V = VAR / numsimm
            df1 = df[3:4]
            dff = []
            for k in G.nodes:
                for n in BC:
                    if k == n:
                        dff.append(BC[n])
            T = max(dff)

            H = pd.DataFrame(dff)
            H['BCMax'] = T
            H.rename(columns={0: 'BCentrality'}, inplace=True)
            H['Hier'] = (H['BCMax'] - H['BCentrality'])
            Q = np.mean(H['Hier'])
            v = Q * V

            BC1 = nx.betweenness_centrality(F)
            isinstance(BC1, dict)
            df1 = pd.DataFrame(lll)
            BC1A = []
            for x in A1:
                for n in BC1:
                    if x == n:
                        BC1A.append(BC1[n])
            BC1B = []
            for y in B1:
                for n in BC1:
                    if y == n:
                        BC1B.append(BC1[n])
            df1['BC1A'] = BC1A
            df1['BC1B'] = BC1B
            df1['AVG1'] = (df1['BC1A'] + df1['BC1B']) / 2
            df1['VAR1'] = ((df1['BC1A'] - df1['AVG1']) ** 2 + (df1['BC1B'] - df1['AVG1']) ** 2) / 2
            V1 = np.mean(df1['VAR1'])
            dff1 = []
            for k in G.nodes:
                for n in BC1:
                    if k == n:
                        dff1.append(BC1[n])
            T1 = max(dff1)
            H1 = pd.DataFrame(dff1)
            H1['BC1Max'] = T1
            H1.rename(columns={0: 'BCentrality1'}, inplace=True)
            H1['Hier1'] = (H1['BC1Max'] - H1['BCentrality1'])
            Vl = V / V1
            nx.set_edge_attributes(G, 0, name='imitation')
            for n in G.nodes:
                G.nodes[n]['imitation'] = randrange(1, 10) / 100

            sup = []
            for (i, j) in F.edges:
                sup.append((j, i))

            sub = F.edges

            nx.set_edge_attributes(G, 0, name='theta')
            for n in G.nodes:
                G.nodes[n]['theta'] = randrange(1, 10) / 500
            nx.set_edge_attributes(G, 0, name='ego')
            for n in G.nodes:
                G.nodes[n]['ego'] = randrange(4, 9) / 10
            nx.set_node_attributes(G, 0, name='relevance')
            primi = random.sample(range(0, num), primini)

            for n in primi:
                G.nodes[n]['relevance'] = 1

            nx.set_edge_attributes(G, 0, name='threshold')
            for n in G.nodes:
                G.nodes[n]['threshold'] = np.random.beta(1, 10)

            influence_matrix = np.matrix(np.zeros((num, num)))
            for i in G.nodes:
                for j in G.nodes:
                    if i != j:
                        if j in G.neighbors(i):
                            if BC[i] - BC[j] < 0:
                                influence_matrix[i, j] = (np.random.beta(1, 8) / len(list(G.neighbors(i))))
                            elif BC[i] - BC[j] > 0:
                                influence_matrix[i, j] = np.random.beta(3, 7) / len(list(G.neighbors(i)))
                            elif BC[i] - BC[j] == 0:
                                influence_matrix[i, j] = np.random.beta(4, 3) / len(list(G.neighbors(i)))
                influence_matrix[i, i] = (1 - influence_matrix[[i]].sum(axis=1))

            probability_matrix = np.matrix(np.zeros((num, num)))
            for i in G.nodes:
                for j in G.nodes:
                    if i == j:
                        probability_matrix[i, j] = 1
                    elif i != j:
                        if [i, j] in simmelian:
                            if BC[i] - BC[j] > 0:
                                probability_matrix[i, j] = np.random.beta(8, 1)
                            elif BC[i] - BC[j] < 0:
                                probability_matrix[i, j] = np.random.beta(8, 1)
                            elif BC[i] - BC[j] == 0:
                                probability_matrix[i, j] = np.random.beta(8, 1)
                        elif [i, j] not in simmelian:
                            if BC[i] - BC[j] > 0:
                                probability_matrix[i, j] = np.random.beta(4, 2)
                            elif BC[i] - BC[j] < 0:
                                probability_matrix[i, j] = np.random.beta(4, 2)
                            elif BC[i] - BC[j] == 0:
                                probability_matrix[i, j] = np.random.beta(4, 3)

            def degroot(G):
                K = G.copy()
                t = 1
                bellini = []

                def event():
                    P = K.copy()
                    for i in K.nodes:
                        opchange = [P.nodes[i]['relevance'] * influence_matrix[i, i]]
                        for j in K.neighbors(i):
                            if P.nodes[j]['relevance'] >= P.nodes[j]['threshold']:
                                if random.random() < probability_matrix[i, j]:
                                    opchange.append(influence_matrix[i, j])

                        opchange.append(P.nodes[i]['relevance'])
                        K.nodes[i]["relevance"] = np.sum(opchange) - K.nodes[i]['theta']
                    return K

                dati = [Vl]
                datelli = []
                while t != steps:
                    t += 1
                    event()
                    P = []
                    for n in K.nodes:
                        if K.nodes[n]['relevance'] >= K.nodes[n]['threshold']:
                            P.append(K.nodes[n]['relevance'])
                            if n not in bellini:
                                bellini.append(n)
                    dati.append((len(P) / num))
                    datelli.append((len(bellini) / num))

                return [dati, datelli]

            def contagion(G):
                K = G.copy()
                t = 1
                bellini = []

                def event():
                    P = K.copy()
                    for i in K.nodes:
                        opchange = [P.nodes[i]['relevance'] * influence_matrix[i, i]]
                        for j in K.neighbors(i):
                            if P.nodes[j]['relevance'] >= P.nodes[j]['threshold']:
                                if random.random() < probability_matrix[i, j]:
                                    opchange.append(influence_matrix[i, j] * P.nodes[j]['relevance'])
                                if random.random() > probability_matrix[i, j]:
                                    opchange.append(influence_matrix[i, j] * P.nodes[i]['relevance'])
                            if P.nodes[j]['relevance'] < P.nodes[j]['threshold']:
                                opchange.append(influence_matrix[i, j] * P.nodes[i]['relevance'])
                        K.nodes[i]["relevance"] = np.sum(opchange)

                    return K

                dati = [Vl]
                datelli = []
                while t != steps:
                    t += 1
                    event()
                    P = []
                    for n in K.nodes:
                        if K.nodes[n]['relevance'] >= K.nodes[n]['threshold']:
                            P.append(K.nodes[n]['relevance'])
                            if n not in bellini:
                                bellini.append(n)
                    dati.append((len(P) / num))
                    datelli.append((len(bellini) / num))

                return [dati, datelli]

            def bass(G):
                K = G.copy()
                t = 1
                bellini = []

                def event(G):
                    nonsimmy = []
                    simmy = []
                    for i in K.nodes:
                        if K.nodes[i] in simmelian:
                            if K.nodes[i]['relevance'] > K.nodes[i]['threshold']:
                                simmy.append(n)
                        if K.nodes[i] not in simmelian:
                            if K.nodes[i]['relevance'] > K.nodes[i]['threshold']:
                                nonsimmy.append(i)
                    prob = ((len(simmy) * Vl) + len(nonsimmy)) / len(G.nodes)
                    for i in K.nodes:
                        if K.nodes[i]['relevance'] <= K.nodes[i]['threshold']:
                            if random.random() < G.nodes[i]['imitation'] * prob:
                                K.nodes[i]['relevance'] = 1
                    return K

                dati = [Vl]
                datelli = []
                while t != steps:
                    t += 1
                    event(K)
                    P = []
                    for n in K.nodes:
                        if K.nodes[n]['relevance'] >= K.nodes[n]['threshold']:
                            P.append(K.nodes[n]['relevance'])
                            if n not in bellini:
                                bellini.append(n)
                    dati.append((len(P) / num))
                    datelli.append((len(bellini) / num))

                return [dati, datelli]

            return [degroot(G), contagion(G), bass(G), Vl]

        actualdegroot = []
        actualcontagion = []
        actualbass = []
        actualphi = []
        cumulativedegroot = []
        cumulativecontagion = []
        cumulativebass = []
        startTime = time.time()

        while m != iters:
            banana = tutto()
            executiontime = (time.time() - startTime)
            ETA = int((((executiontime / (m+1)) * (iters - m))) / 60)
            print(int((m / iters) * 100), '% Estimated time remaining:',
                  ETA,
                  'minutes')
            if m== steps/10:
                bot.send_message(message.chat.id, 'Hi! 'u'\U0001F916 just to let you know that the analysis has been'
                                                  ' set properly! 10% of the process has been carried out!'
                                                  '\nEstimated time remaining: {} minutes'.format(ETA))
            elif m==steps/2:
                bot.send_message(message.chat.id, 'Hi! 'u'\U0001F916 just to let you know that we are half-way done!'
                                                  '\nEstimated time remaining: {} minutes'.format(ETA))
            elif m==steps*0.9:
                bot.send_message(message.chat.id, 'Hi! 'u'\U0001F916 just to let you know that we are nearly done!'
                                                  '\n90% of the process has been carried out!'
                                                  '\nEstimated time remaining: {} minutes'.format(ETA))
            m += 1
            actualdegroot.append(banana[0][0])
            actualcontagion.append(banana[1][0])
            actualbass.append(banana[2][0])
            actualphi.append(banana[3])
            cumulativedegroot.append((banana[0][1]))
            cumulativecontagion.append((banana[1][1]))
            cumulativebass.append((banana[2][1]))
        dat = np.array(actualdegroot)
        for n in dat:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('DeGroot model (as modified by Assenova 2018)')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()
        datcumulatividegroot = np.array(cumulativedegroot)
        for n in datcumulatividegroot:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('DeGroot model (as modified by Assenova 2018)')
        plt.xlabel('Time steps')
        plt.ylabel('Cumulative adoption rate')
        bott.send_plot(plt)
        plt.clf()
        lst = []
        n = len(tutto()[0][0])
        for i in range(n + 0):
            lst.append(i)
        minimo = []
        massimo = []
        media = []
        mediana = []

        for l in np.array(lst):
            minimo.append(dat[:, l].min())
            massimo.append(dat[:, l].max())
            media.append(dat[:, l].mean())
            mediana.append(np.median(dat[:, l], axis=0))

        plt.plot(minimo[1:], label='minimum')
        plt.plot(massimo[1:], label='maximum')
        plt.plot(media[1:], label='mean')
        plt.plot(mediana[1:], 'r--',label='median')
        plt.legend()
        plt.title('DeGroot model (as modified by Assenova 2018)')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()

        datcontagion = np.array(actualcontagion)
        for n in datcontagion:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('Piccione-Tolotti 2022')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()
        datcumulativicontagion = np.array(cumulativecontagion)
        for n in datcumulativicontagion:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('Piccione-Tolotti 2022')
        plt.xlabel('Time steps')
        plt.ylabel('Cumulative adoption rate')
        bott.send_plot(plt)
        plt.clf()
        lstcontagion = []
        n = len(tutto()[1][0])
        for i in range(n + 0):
            lstcontagion.append(i)
        minimo = []
        massimo = []
        media = []
        mediana = []
        for l in np.array(lstcontagion):
            minimo.append(datcontagion[:, l].min())
            massimo.append(datcontagion[:, l].max())
            media.append(datcontagion[:, l].mean())
            mediana.append(np.median(datcontagion[:, l], axis=0))

        plt.plot(minimo[1:], label='minimum')
        plt.plot(massimo[1:], label='maximum')
        plt.plot(media[1:], label='mean')
        plt.plot(mediana[1:], 'r--',label='median')
        plt.legend()
        plt.title('Piccione-Tolotti 2022')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()

        datbass = np.array(actualbass)
        for n in datbass:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('Bass (1969) model')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()
        datcumulativibass = np.array(cumulativebass)
        for n in datcumulativibass:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('Bass (1969) model')
        plt.xlabel('Time steps')
        plt.ylabel('Cumulative adoption rate')
        bott.send_plot(plt)
        plt.clf()
        lstbass = []
        n = len(tutto()[2][0])
        for i in range(n + 0):
            lstbass.append(i)
        minimo = []
        massimo = []
        media = []
        mediana = []

        for l in np.array(lstbass):
            minimo.append(datbass[:, l].min())
            massimo.append(datbass[:, l].max())
            media.append(datbass[:, l].mean())
            mediana.append(np.median(datbass[:, l], axis=0))

        plt.plot(minimo[1:], label='minimum')
        plt.plot(massimo[1:], label='maximum')
        plt.plot(media[1:], label='mean')
        plt.plot(mediana[1:], 'r--',label='median')
        plt.legend()
        plt.title('Bass (1969) model')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        print(data)
        plt.clf()
        del data[:]



@bot.message_handler(commands=['Steps'])
def greet(message):
    bot.reply_to(message, "we still need to develop this part of the program. please, stay tuned. \nYou may want to check"
                 "the other /Commands")

@bot.message_handler(commands=['Parameter_analysis'])
def greet(message):
    bot.reply_to(message, "Excellent choice, dear. This type of analysis will execute the Bass (1969), the DeGroot (1974)"
                          "and the Piccione-Tolotti model (2022) on a randomly generated"
                          "network (Barabasi random graph). Before proceeding, we need to define the parameters necessary."
                          "For instance, we need to define:"
                          "\nThe number of nodes on our network; \nThe k parameter (da spiegare); \nThe number of time steps;\nFinally,"
                          "The number of simulations"
                          "Do you want to proceed?"
                          "\n/Yes_I_want_to_proceed_with_parameter_analysis"
                          "\n/Go_back_to_menu")


@bot.message_handler(
        commands=['Yes_I_want_to_proceed_with_parameter_analysis','Yes_I_want_to_restart_the_parameter_analysis'])
def handle_text(message):
        del data[:]
        cid = message.chat.id
        msgValuenodes2 = bot.send_message(cid, 'How many nodes does the network have?')
        bot.register_next_step_handler(msgValuenodes2, step_Set_Valuenodes2)

def step_Set_Valuenodes2(message):
    userValuenodes2 = message.text
    if userValuenodes2.isnumeric() == True:
        print(userValuenodes2)
        msgValuek2 = bot.send_message(message.chat.id,
                                     'The network will have {} nodes. \nWhat is the value of k? (suggested, between 2 and 15)'.format(
                                         userValuenodes2))
        bot.register_next_step_handler(msgValuek2, step_Set_Valuek2)
        data.append(int(userValuenodes2))
    else:
        bot.send_message(message.chat.id,
                         "The input is not valid. Utilize only integer numbers. The process is being interrupted. Do you want"
                         " to restart the process"
                         "\n/Yes_I_want_to_restart_the_parameter_analysis"
                         "\n No, /Go_back_to_menu")

def step_Set_Valuek2(message):
    userValuek2 = message.text
    if userValuek2.isnumeric() == True:
        if 1 < int(userValuek2) < data[0]:
            print(userValuek2)
            msgValuesteps2 = bot.send_message(message.chat.id,
                                             'The parameter k will have a value of {}. \nHow many steps do we want in each simulation?'.format(
                                                 userValuek2))
            bot.register_next_step_handler(msgValuesteps2, step_Set_Valuesteps2)
            data.append(int(userValuek2))
        else:
            bot.send_message(message.chat.id, "Attention! The parameter k has to be lower than the number of nodes and higher than 1."
                                              " The process is being interrupted. Do you want to restart the process?"
                                              "\n/Yes_I_want_to_restart_the_parameter_analysis"
                                              "\n No, /Go_back_to_menu")

    else:
        bot.send_message(message.chat.id,
                         "Utilize only integer numbers. The process is being interrupted. Do you want"
                         " to restart the process?"
                         "\n/Yes_I_want_to_restart_the_parameter_analysis"
                         "\n No, /Go_back_to_menu")

def step_Set_Valuesteps2(message):
    userValuesteps2 = message.text
    if userValuesteps2.isnumeric() == True:
        print(userValuesteps2)
        msgValuesimulations2 = bot.send_message(message.chat.id,
                                               'The number of steps for each simulation will be {}.'
                                               '\nHow many times do you want to repeat the simulations?'.format(
                                                   userValuesteps2))
        bot.register_next_step_handler(msgValuesimulations2, step_Set_Valuesimulations2)
        data.append(int(userValuesteps2))

    else:
        bot.send_message(message.chat.id,
                         "Utilize only integer numbers. The process is being interrupted. Do you want"
                         " to restart the process?"
                         "\n/Yes_I_want_to_restart_the_parameter_analysis"
                         "\n No, /Go_back_to_menu")



def step_Set_Valuesimulations2(message):
    userValuesimulations2 = message.text
    if userValuesimulations2.isnumeric() == True:
        print(userValuesimulations2)
        msgValueprime2= bot.send_message(message.chat.id, "{} simulations will be carried out. \nHow many subjects are aware of the information at time 0?".format(userValuesimulations2))
        data.append(int(userValuesimulations2))
        bot.register_next_step_handler(msgValueprime2,step_set_Valueprime2)

def step_set_Valueprime2(message):
    userValueprime2 = message.text
    if userValueprime2.isnumeric()==True:
        print(userValueprime2)
        bot.send_message(message.chat.id, "{} people will be aware of the information at time t=0.".format(userValueprime2))
        data.append(int(userValueprime2))
        message_confirmation2 = bot.send_message(message.chat.id,
                                                "Summarizing. \nYou want to carry out {} simulations, each of which composed by {} time steps"
                                                " regarding the Bass, the DeGroot and the Piccione-Tolotti models on a network of {} nodes built with a k of value {}."
                                                "\nAt time 0, {} will be aware of the information"
                                                "\nDo you confirm?"
                                                "\n/Yes"
                                                "\n/Go_back (click twice)"
                                                "\n/Go_back_to_menu (click twice)".format(data[3], data[2], data[0], data[1], data[4]))
        bot.register_next_step_handler(message_confirmation2, carryiton2)


    else:
        bot.send_message(message.chat.id,
                         "Utilize only integer numbers. The process is being interrupted. Do you want"
                         " to restart the process?"
                         "\n/Yes_I_want_to_restart_the_parameter_analysis"
                         "\n No, /Go_back_to_menu")

def carryiton2(message):
    if '/Yes' in message.text.split():
        bot.send_message(message.chat.id, "Perfect! The process has been initiated! You will soon receive updates"
                                          " regarding the prosecution of the analyses. Please, for the time remaining,"
                                          " do not write anything")
        bott = tb('2125748147:AAHiKWSFJ7vXqFBPLu0qjNYHPuFt1zL3uqo', message.chat.id)

        iters = data[3]
        steps = data[2]
        par = data[1]
        num = data[0]
        primini = data[4]
        m = 0
        def tutto():
            p = par

            F = nx.random_tree(n=num, create_using=nx.DiGraph, )
            G = nx.barabasi_albert_graph(num, p)

            def combine(arr, s):
                return list(combinations(arr, s))

            def Control_Centrality(F):
                length = len(F.nodes)
                i = 1

                def CC(F):
                    pippa = F.out_degree()
                    pippa1 = np.array(pippa)
                    pippa2 = pippa1[pippa1[:, 1] != 0]
                    F = F.subgraph(pippa2[:, 0])
                    return F

                def layer(F):
                    culo = [x for x in F.nodes if x not in CC(F).nodes]
                    banana = [i] * len(culo)
                    results = np.column_stack((culo, banana))
                    return results

                results = layer(F)
                while len(results) < length:
                    results = np.concatenate([results, layer(F)])
                    results = np.unique(results, axis=0)
                    i += 1
                    F = CC(F)
                    layer(F)
                return dict(zip(results[:, 0], (results[:, 1])))

            BC = nx.betweenness_centrality(F)

            isinstance(BC, dict)
            list(G.nodes)

            lll = combinations(G.nodes(), 2)
            lll = np.matrix(list(lll))
            cliques = list(nx.enumerate_all_cliques(G))
            triads = [i for i in cliques if len(i) == 3]
            simm = []
            for n in triads:
                for l in combine(n, 2):
                    simm.append(l)

            simmelian = []
            for i in simm:
                if i not in simmelian:
                    simmelian.append(i)

            simmelian = np.array(simmelian)

            A = simmelian[:, 0]
            B = simmelian[:, 1]
            A1 = lll[:, 0]
            B1 = lll[:, 1]
            df = pd.DataFrame(simmelian)
            numsimm = len(simmelian)

            BCA = []
            for x in A:
                for n in BC:
                    if x == n:
                        BCA.append(BC[n])
            BCB = []
            for y in B:
                for n in BC:
                    if y == n:
                        BCB.append(BC[n])

            df['BCA'] = BCA
            df['BCB'] = BCB
            df['AVG'] = (df['BCA'] + df['BCB']) / 2
            df['VAR'] = (((df['BCA'] - df['AVG']) ** 2 + (df['BCB'] - df['AVG']) ** 2) / 2)
            VAR = np.sum(df['VAR'])
            V = VAR / numsimm
            df1 = df[3:4]
            dff = []
            for k in G.nodes:
                for n in BC:
                    if k == n:
                        dff.append(BC[n])
            T = max(dff)

            H = pd.DataFrame(dff)
            H['BCMax'] = T
            H.rename(columns={0: 'BCentrality'}, inplace=True)
            H['Hier'] = (H['BCMax'] - H['BCentrality'])
            Q = np.mean(H['Hier'])
            v = Q * V

            BC1 = nx.betweenness_centrality(F)
            isinstance(BC1, dict)
            df1 = pd.DataFrame(lll)
            BC1A = []
            for x in A1:
                for n in BC1:
                    if x == n:
                        BC1A.append(BC1[n])
            BC1B = []
            for y in B1:
                for n in BC1:
                    if y == n:
                        BC1B.append(BC1[n])
            df1['BC1A'] = BC1A
            df1['BC1B'] = BC1B
            df1['AVG1'] = (df1['BC1A'] + df1['BC1B']) / 2
            df1['VAR1'] = ((df1['BC1A'] - df1['AVG1']) ** 2 + (df1['BC1B'] - df1['AVG1']) ** 2) / 2
            V1 = np.mean(df1['VAR1'])
            dff1 = []
            for k in G.nodes:
                for n in BC1:
                    if k == n:
                        dff1.append(BC1[n])
            T1 = max(dff1)
            H1 = pd.DataFrame(dff1)
            H1['BC1Max'] = T1
            H1.rename(columns={0: 'BCentrality1'}, inplace=True)
            H1['Hier1'] = (H1['BC1Max'] - H1['BCentrality1'])
            Vl = V / V1
            nx.set_edge_attributes(G, 0, name='imitation')
            for n in G.nodes:
                G.nodes[n]['imitation'] = randrange(1, 10) / 100

            sup = []
            for (i, j) in F.edges:
                sup.append((j, i))

            sub = F.edges

            nx.set_edge_attributes(G, 0, name='theta')
            for n in G.nodes:
                G.nodes[n]['theta'] = randrange(1, 10) / 500
            nx.set_edge_attributes(G, 0, name='ego')
            for n in G.nodes:
                G.nodes[n]['ego'] = randrange(4, 9) / 10
            nx.set_node_attributes(G, 0, name='relevance')
            primi = random.sample(range(0, num), primini)

            for n in primi:
                G.nodes[n]['relevance'] = 1

            def modelling(meansup, meansequal, meansdown, meannup, meannequal, meanndown, meanthr, sigmas, sigman,
                          sigmathr):
                """
                sup is when the information is going upward, down when it goes downward. if the information is going
                upword, it means that subject i is the superior


                for mean 0.8 is max and 0.2 minimum
                for sigma 0.05 is max and 0.01 is minimum
                """
                influence_matrix = np.matrix(np.zeros((num, num)))
                for i in G.nodes:
                    for j in G.nodes:
                        if i != j:
                            if j in G.neighbors(i):
                                if BC[i] - BC[j] < 0:
                                    influence_matrix[i, j] = np.random.normal(meanndown, sigman) / len(list(G.neighbors(i)))
                                elif BC[i] - BC[j] > 0:
                                    influence_matrix[i, j] = np.random.normal(meannup, sigman) / len(list(G.neighbors(i)))
                                elif BC[i] - BC[j] == 0:
                                    influence_matrix[i, j] = np.random.normal(meannequal, sigman) / len(list(G.neighbors(i)))
                        if influence_matrix[i, j] < 0:
                            influence_matrix[i, j] = 0
                        elif influence_matrix[i, j] > 1:
                            influence_matrix[i, j] = 1
                    influence_matrix[i, i] = (1 - influence_matrix[[i]].sum(axis=1))

                probability_matrix = np.matrix(np.zeros((num, num)))
                for i in G.nodes:
                    for j in G.nodes:
                        if i == j:
                            probability_matrix[i, j] = 1
                        elif i != j:
                            if [i, j] in simmelian:
                                if BC[i] - BC[j] > 0:
                                    probability_matrix[i, j] = np.random.normal(meansup, sigmas)
                                elif BC[i] - BC[j] < 0:
                                    probability_matrix[i, j] = np.random.normal(meansdown, sigmas)
                                elif BC[i] - BC[j] == 0:
                                    probability_matrix[i, j] = np.random.normal(meansequal, sigmas)
                            elif [i, j] not in simmelian:
                                if BC[i] - BC[j] > 0:
                                    probability_matrix[i, j] = np.random.normal(meannup, sigman)
                                elif BC[i] - BC[j] < 0:
                                    probability_matrix[i, j] = np.random.normal(meanndown, sigman)
                                elif BC[i] - BC[j] == 0:
                                    probability_matrix[i, j] = np.random.normal(meannequal, sigman)
                        if probability_matrix[i, j] < 0:
                            probability_matrix[i, j] = 0
                        elif probability_matrix[i, j] > 1:
                            probability_matrix[i, j] = 1


                nx.set_edge_attributes(G, 0, name='threshold')
                for n in G.nodes:
                    G.nodes[n]['threshold'] = np.random.normal(meanthr, sigmathr)
                    if G.nodes[n]['threshold'] > 1:
                        G.nodes[n]['threshold'] = 1
                    elif G.nodes[n]['threshold'] < 0:
                        G.nodes[n]['threshold'] = 0


                K = G.copy()
                t = 0
                bellini = []

                def event():
                    P = K.copy()
                    for i in K.nodes:
                        opchange = [P.nodes[i]['relevance'] * influence_matrix[i, i]]
                        for j in K.neighbors(i):
                            if P.nodes[j]['relevance'] >= P.nodes[j]['threshold']:
                                if random.random() < probability_matrix[i, j]:
                                    opchange.append(influence_matrix[i, j] * P.nodes[j]['relevance'])
                                if random.random() > probability_matrix[i, j]:
                                    opchange.append(influence_matrix[i, j] * P.nodes[i]['relevance'])
                            if P.nodes[j]['relevance'] < P.nodes[j]['threshold']:
                                opchange.append(influence_matrix[i, j] * P.nodes[i]['relevance'])
                        K.nodes[i]["relevance"] = np.sum(opchange)

                    return K

                dati = [Vl,(primini/num)]
                datelli = [(primini/num)]
                while t != steps:

                    event()
                    P = []
                    for n in K.nodes:
                        if K.nodes[n]['relevance'] >= K.nodes[n]['threshold']:
                            P.append(K.nodes[n]['relevance'])
                            if n not in bellini:
                                bellini.append(n)
                    dati.append((len(P) / num))
                    datelli.append((len(bellini) / num))
                    t += 1

                return [dati, datelli]

            """
                    sup is when the information is going upward, down when it goes downward. if the information is going
                    upword, it means that subject i is the superior
    
    
                    for mean 0.8 is max and 0.2 minimum
                    for sigma 0.05 is max and 0.01 is minimum
                    """

            return [modelling(meansup=1, meansequal=1, meansdown=1, meannup=1, meannequal=1, meanndown=1, meanthr=0.01,
                              sigmas=0, sigman=0, sigmathr=0),
                    modelling(meansup=1, meansequal=1, meansdown=1, meannup=1, meannequal=1, meanndown=1, meanthr=0.9,
                              sigmas=0, sigman=0, sigmathr=0),
                    modelling(meansup=0.2, meansequal=0.4, meansdown=0.6, meannup=0.2, meannequal=0.4, meanndown=0.6, meanthr=0.9,
                              sigmas=0, sigman=0, sigmathr=0),
                    modelling(meansup=0.2, meansequal=0.4, meansdown=0.6, meannup=0.2, meannequal=0.4, meanndown=0.6, meanthr=0.9,
                              sigmas=0.01, sigman=0.05, sigmathr=0.05),
                    modelling(meansup=0.6, meansequal=0.7, meansdown=0.8, meannup=0.2, meannequal=0.4, meanndown=0.6,meanthr=0.9,
                              sigmas=0.01, sigman=0.05, sigmathr=0.05),Vl]

        """
        the first one is with no thresholod
        the second one is with average threshold
        the third one includes differences between levels
        the fourth one considers divergencies between simmelian and non simmelian
        """

        DATONIA = []
        DATONIB = []
        DATONIC = []
        DATONID = []
        DATONIE = []
        DATONIphi = []
        cumulativeA = []
        cumulativeB = []
        cumulativeC = []
        cumulativeD = []
        cumulativeE = []
        startTime = time.time()

        while m != iters:
            banana = tutto()
            executiontime = (time.time() - startTime)
            ETA = int((((executiontime / (m + 1)) * (iters - m))) / 60)
            print(int((m / iters) * 100), '% Estimated time remaining:',
                  ETA,
                  'minutes')
            if m == steps / 10:
                bot.send_message(message.chat.id, 'Hi! 'u'\U0001F916 just to let you know that the analysis has been'
                                                  ' set properly! 10% of the process has been carried out!'
                                                  '\nEstimated time remaining: {} minutes'.format(ETA))
            elif m == steps / 2:
                bot.send_message(message.chat.id, 'Hi! 'u'\U0001F916 just to let you know that we are half-way done!'
                                                  '\nEstimated time remaining: {} minutes'.format(ETA))
            elif m == steps * 0.9:
                bot.send_message(message.chat.id, 'Hi! 'u'\U0001F916 just to let you know that we are nearly done!'
                                                  '\n90% of the process has been carried out!'
                                                  '\nEstimated time remaining: {} minutes'.format(ETA))
            m += 1
            print(int((m / iters) * 100), '% Estimated time remaining:', int((((executiontime / (m)) * (iters - m))) / 60),
                  'minutes')
            DATONIA.append(banana[0][0])
            DATONIB.append(banana[1][0])
            DATONIC.append(banana[2][0])
            DATONID.append(banana[3][0])
            DATONIE.append(banana[4][0])
            DATONIphi.append(banana[5])
            cumulativeA.append((banana[0][1]))
            cumulativeB.append((banana[1][1]))
            cumulativeC.append((banana[2][1]))
            cumulativeD.append((banana[3][1]))
            cumulativeE.append((banana[4][1]))

        dat = np.array(DATONIA)
        for n in dat:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 1: Every parameter is fixed')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()
        datcumulativeA = np.array(cumulativeA)
        for n in datcumulativeA:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 1: Every parameter is fixed')
        plt.xlabel('Time steps')
        plt.ylabel('Cumulative adoption rate')
        bott.send_plot(plt)
        plt.clf()
        lstDATONIA = []
        n = len(tutto()[1][0])
        for i in range(n + 0):
            lstDATONIA.append(i)
        minimo = []
        massimo = []
        media = []
        mediana = []
        for l in np.array(lstDATONIA):
            minimo.append(dat[:, l].min())
            massimo.append(dat[:, l].max())
            media.append(dat[:, l].mean())
            mediana.append(np.median(dat[:, l], axis=0))
        plt.plot(minimo[1:], label='minimum')
        plt.plot(massimo[1:], label='maximum')
        plt.plot(media[1:], label='mean')
        plt.plot(mediana[1:], 'r--',label='median')
        plt.legend()
        plt.title('step 1: Every parameter is fixed')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()

        dat = np.array(DATONIB)
        for n in dat:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 2: a (random) threshold is assigned')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()
        datcumulativeB = np.array(cumulativeB)
        for n in datcumulativeB:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 2: a (random) threshold is assigned')
        plt.xlabel('Time steps')
        plt.ylabel('Cumulative adoption rate')
        bott.send_plot(plt)
        plt.clf()
        lstDATONIB = []
        n = len(tutto()[1][0])
        for i in range(n + 0):
            lstDATONIB.append(i)
        minimo = []
        massimo = []
        media = []
        mediana = []
        for l in np.array(lstDATONIB):
            minimo.append(dat[:, l].min())
            massimo.append(dat[:, l].max())
            media.append(dat[:, l].mean())
            mediana.append(np.median(dat[:, l], axis=0))
        plt.plot(minimo[1:], label='minimum')
        plt.plot(massimo[1:], label='maximum')
        plt.plot(media[1:], label='mean')
        plt.plot(mediana[1:], 'r--', label='median')
        plt.legend()
        plt.title('step 2: a (random) threshold is assigned')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()

        dat = np.array(DATONIC)
        for n in dat:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 3: introducing differences between levels')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()
        datcumulativeC = np.array(cumulativeC)
        for n in datcumulativeC:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 3: introducing differences between levels')
        plt.xlabel('Time steps')
        plt.ylabel('Cumulative adoption rate')
        bott.send_plot(plt)
        plt.clf()
        lstDATONIC = []
        n = len(tutto()[1][0])
        for i in range(n + 0):
            lstDATONIC.append(i)
        minimo = []
        massimo = []
        media = []
        mediana = []
        for l in np.array(lstDATONIC):
            minimo.append(dat[:, l].min())
            massimo.append(dat[:, l].max())
            media.append(dat[:, l].mean())
            mediana.append(np.median(dat[:, l], axis=0))
        plt.plot(minimo[1:], label='minimum')
        plt.plot(massimo[1:], label='maximum')
        plt.plot(media[1:], label='mean')
        plt.plot(mediana[1:], 'r--', label='median')
        plt.legend()
        plt.title('step 3: introducing differences between levels')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()

        dat = np.array(DATONID)
        for n in dat:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 4: introducing differences between Simmelian and non simmelian (sigma)')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()
        datcumulativeD = np.array(cumulativeD)
        for n in datcumulativeD:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 4: introducing differences between Simmelian and non simmelian (sigma)')
        plt.xlabel('Time steps')
        plt.ylabel('Cumulative adoption rate')
        bott.send_plot(plt)
        plt.clf()
        lstDATONID = []
        n = len(tutto()[1][0])
        for i in range(n + 0):
            lstDATONID.append(i)
        minimo = []
        massimo = []
        media = []
        mediana = []
        for l in np.array(lstDATONID):
            minimo.append(dat[:, l].min())
            massimo.append(dat[:, l].max())
            media.append(dat[:, l].mean())
            mediana.append(np.median(dat[:, l], axis=0))
        plt.plot(minimo[1:], label='minimum')
        plt.plot(massimo[1:], label='maximum')
        plt.plot(media[1:], label='mean')
        plt.plot(mediana[1:], 'r--', label='median')
        plt.legend()
        plt.title('step 4: introducing differences between Simmelian and non simmelian (sigma)')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()

        dat = np.array(DATONIE)
        for n in dat:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 5: introducing differences between Simmelian and non simmelian (sigma and mean)')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()
        datcumulativeE = np.array(cumulativeE)
        for n in datcumulativeE:
            if n[0] < 1:
                plt.plot(n[1:], 'k', alpha=0.1, label='Non-heterarchical')
            if n[0] > 1:
                plt.plot(n[1:], 'r', alpha=0.1, label='Heterarchical')
        plt.title('step 5: introducing differences between Simmelian and non simmelian (sigma and mean)')
        plt.xlabel('Time steps')
        plt.ylabel('Cumulative adoption rate')
        bott.send_plot(plt)
        plt.clf()
        lstDATONIE = []
        n = len(tutto()[1][0])
        for i in range(n + 0):
            lstDATONIE.append(i)
        minimo = []
        massimo = []
        media = []
        mediana = []
        for l in np.array(lstDATONIE):
            minimo.append(dat[:, l].min())
            massimo.append(dat[:, l].max())
            media.append(dat[:, l].mean())
            mediana.append(np.median(dat[:, l], axis=0))
        plt.plot(minimo[1:], label='minimum')
        plt.plot(massimo[1:], label='maximum')
        plt.plot(media[1:], label='mean')
        plt.plot(mediana[1:], 'r--', label='median')
        plt.legend()
        plt.title('step 5: introducing differences between Simmelian and non simmelian (sigma and mean)')
        plt.xlabel('Time steps')
        plt.ylabel('Actual adoption rate')
        bott.send_plot(plt)
        plt.clf()





print('Bot started...')
while True:
    bot.polling()

